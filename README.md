# TerrainGenerator
![Terrain Image]
(https://github.com/sksharan/TerrainGenerator/blob/master/TerrainGenerator/images/terrain.png)

**TerrainGenerator** is a program that generates infinite landscapes using OpenGL 4.3. The landscape is generated in chunks, and each chunk uses a modified "split-only" version of the ROAM algorithm for level of detail. Textures are applied to the terrain based on the slope of the land (grass on flat land and rock on steep land), and grass blades are generated at runtime through the use of a geometry shader. OpenMP is used for added performance: one thread handles the main loop logic while another thread focuses solely on updating the landscape. This GitHub repository contains the Visual Studio 2013 Solution file. When running the program, use W, A, S, D to move around, E to switch between walk mode and fly mode, R to toggle wireframe mode on/off, and ESC to exit the program.

ROAM is a continuous level of detail algorithm conceived in the 1990s. The original paper can be found at https://graphics.llnl.gov/ROAM/roam.pdf. The logic for creating terrain using ROAM can be found in <code>ROAMTerrain.cpp</code>. The terrain is represented as a binary triangle tree whose roots define the traingles of the terrain mesh. The original paper uses a priority queue to decide which triangles to "split" (i.e., where to add more detail to the mesh), but an <code>std::multiset</code> is used in place of an <code>std::priority_queue</code> since <i>any</i> element in a <code>std::multiset</code> can be deleted efficiently (logarithmic in the size of the set). The main advantage of having an <code>std::priority_queue</code> is that the highest priority element can be retrieved in constant time, but the highest priority element in a <code>std::multiset</code> can also be found in constant time by calling <code>rbegin()</code> if the correct comparison function is provided. This implementation implements a comparision function in the <code>BTTNodeComp</code> class in <code>BTT.h</code>. While ROAM is implemented in this project for learning purposes, it would be more effective to use other algorithms on modern computers (e.g., GPU-based tessellation using tessellation shaders).

The picture below shows the wireframe for a single chunk of terrain (a single instance of <code>ROAMTerrain</code>), with the viewer at the lower left corner. The number of triangles is greatest closest to the viewer since that is where the most detail in the terrain is required.

![ROAM Wireframe]
(https://github.com/sksharan/TerrainGenerator/blob/master/TerrainGenerator/images/roam_wireframe.png)
